<!DOCTYPE html>
<html>
<head>
  <title>SQLite Web Test</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #f0f0f0; }
    .pass { color: #4ade80; }
    .fail { color: #f87171; }
    .info { color: #60a5fa; }
    pre { background: #2a2a2a; padding: 10px; border-radius: 4px; }
    h1 { color: #fbbf24; }
    h2 { color: #a78bfa; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>ðŸ§ª Prototype 1: SQLite Web Stability</h1>
  <p class="info">Testing expo-sqlite web behavior using sql.js directly</p>
  <div id="output"></div>

  <script>
    const log = (msg, isPass = null) => {
      const div = document.createElement('div');
      if (isPass === true) div.className = 'pass';
      if (isPass === false) div.className = 'fail';
      div.textContent = msg;
      document.getElementById('output').appendChild(div);
      console.log(msg);
    };

    async function runTests() {
      log('Loading sql.js...');

      const SQL = await initSqlJs({
        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
      });

      log('sql.js loaded âœ“');

      // Test 1: Create DB and write 100 records
      log('\n--- Test 1: Write 100 records ---');
      const db = new SQL.Database();

      db.run('CREATE TABLE IF NOT EXISTS favorites (id INTEGER PRIMARY KEY, song_id TEXT, added_at INTEGER)');

      const startWrite = performance.now();
      const stmt = db.prepare('INSERT INTO favorites (song_id, added_at) VALUES (?, ?)');
      for (let i = 0; i < 100; i++) {
        stmt.run([`song-${i}`, Date.now()]);
      }
      stmt.free();
      const writeTime = performance.now() - startWrite;
      log(`Write 100 records: ${writeTime.toFixed(1)}ms`, writeTime < 100);

      // Test 2: Read all records
      log('\n--- Test 2: Read 100 records ---');
      const startRead = performance.now();
      const result = db.exec('SELECT * FROM favorites');
      const readTime = performance.now() - startRead;
      const rowCount = result[0]?.values?.length || 0;
      log(`Read ${rowCount} records: ${readTime.toFixed(1)}ms`, rowCount === 100 && readTime < 100);

      // Test 3: Export to IndexedDB for persistence
      log('\n--- Test 3: Persistence (IndexedDB) ---');
      const data = db.export();
      const blob = new Blob([data], { type: 'application/octet-stream' });

      // Store in IndexedDB - must get arrayBuffer BEFORE starting transaction
      const arrayBuffer = await blob.arrayBuffer();
      await new Promise((resolve, reject) => {
        const dbRequest = indexedDB.open('vampbook-test', 1);
        dbRequest.onupgradeneeded = (e) => {
          e.target.result.createObjectStore('db');
        };
        dbRequest.onsuccess = (e) => {
          try {
            const idb = e.target.result;
            const tx = idb.transaction('db', 'readwrite');
            const store = tx.objectStore('db');
            store.put(arrayBuffer, 'main');
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          } catch (err) {
            reject(err);
          }
        };
        dbRequest.onerror = () => reject(dbRequest.error);
      });

      const storedSize = blob.size;
      log(`Stored in IndexedDB: ${(storedSize / 1024).toFixed(1)}KB`, storedSize > 0);

      // Test 4: Reload from IndexedDB
      log('\n--- Test 4: Reload from IndexedDB ---');
      const loadRequest = indexedDB.open('vampbook-test', 1);
      const loadedData = await new Promise((resolve, reject) => {
        loadRequest.onsuccess = (e) => {
          const idb = e.target.result;
          const tx = idb.transaction('db', 'readonly');
          const store = tx.objectStore('db');
          const getReq = store.get('main');
          getReq.onsuccess = () => resolve(getReq.result);
          getReq.onerror = reject;
        };
      });

      const db2 = new SQL.Database(new Uint8Array(loadedData));
      const result2 = db2.exec('SELECT COUNT(*) FROM favorites');
      const count = result2[0]?.values[0][0];
      log(`Reloaded ${count} records from IndexedDB`, count === 100);

      // Test 5: Update and re-persist
      log('\n--- Test 5: Update + Re-persist ---');
      db.run('INSERT INTO favorites (song_id, added_at) VALUES (?, ?)', ['song-extra', Date.now()]);
      const data2 = db.export();
      const blob2 = new Blob([data2], { type: 'application/octet-stream' });

      const arrayBuffer2 = await blob2.arrayBuffer();
      await new Promise((resolve, reject) => {
        const dbRequest2 = indexedDB.open('vampbook-test', 1);
        dbRequest2.onsuccess = (e) => {
          const idb = e.target.result;
          const tx = idb.transaction('db', 'readwrite');
          const store = tx.objectStore('db');
          store.put(arrayBuffer2, 'main');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        };
        dbRequest2.onerror = () => reject(dbRequest2.error);
      });
      log('Updated and re-persisted âœ“', true);

      // Summary
      log('\n========================================');
      log('SUMMARY');
      log('========================================');
      log(`Write time: ${writeTime.toFixed(1)}ms ${writeTime < 100 ? 'âœ“' : 'âœ—'}`);
      log(`Read time: ${readTime.toFixed(1)}ms ${readTime < 100 ? 'âœ“' : 'âœ—'}`);
      log(`Persistence: ${count === 100 ? 'PASS âœ“' : 'FAIL âœ—'}`);
      log('\nâš ï¸  Multi-tab test: Open this page in 2 tabs simultaneously');
      log('   Both should show 101 records after refresh');
      log('   If one shows 100 and one shows 101 = CORRUPTION');

      const pass = writeTime < 100 && readTime < 100 && count === 100;
      log(`\nOVERALL: ${pass ? 'PASS âœ“' : 'FAIL âœ—'}`, pass);

      // Add reload button
      const btn = document.createElement('button');
      btn.textContent = 'Reload Test';
      btn.style.cssText = 'margin-top: 20px; padding: 10px 20px; font-size: 16px; cursor: pointer;';
      btn.onclick = () => location.reload();
      document.body.appendChild(btn);
    }

    runTests().catch(err => log('ERROR: ' + err.message, false));
  </script>
</body>
</html>
